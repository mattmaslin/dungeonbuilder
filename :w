use room::Room;
use chunk::{Chunk, ChunkSplit};
use point::Point;
use dungeon::Dungeon;
use rand::{Rng, ThreadRng, thread_rng};
use dimensionoptions::DimensionOptions;
use hallway::Hallway;
use hallwayoptions::HallwayOptions;
use std::collections::BinaryHeap;
use std::rc::Rc;

pub struct DungeonBuilder {
    chunks: BinaryHeap<Chunk>,
    rng: ThreadRng,
    dimension_options: Option<DimensionOptions>,
    hallway_options: Option<HallwayOptions>,
    total_area: f32,
}

impl DungeonBuilder  {
    pub fn new() -> DungeonBuilder  {
        DungeonBuilder { 
            chunks: BinaryHeap::new(), 
            rng: thread_rng(), 
            dimension_options: None, 
            hallway_options: None,
            total_area: 0f32,
        }
    }

    pub fn in_area(&mut self, lower_left: Point, upper_right: Point) -> &mut DungeonBuilder {
        let mut chunk_split = ChunkSplit::Horizontal;
        if self.rng.gen_weighted_bool(2) {
            chunk_split = ChunkSplit::Vertical;
        }
        let chunk = Chunk::new(lower_left, upper_right, chunk_split);
        self.total_area = chunk.area();
        self.chunks.push(chunk);
        self        
    }

    pub fn with_dimension_options(&mut self, dimension_options: DimensionOptions) -> &mut DungeonBuilder {
        self.dimension_options = Some(dimension_options);
        self
    }

    pub fn with_hallway_options(&mut self, hallway_options: HallwayOptions) -> &mut DungeonBuilder {
        self.hallway_options = Some(hallway_options);
        self
    }

    pub fn build(&mut self) -> Dungeon {
        let mut total_hallway_percent = 0f32;
        let mut dungeon = Dungeon::new();
        let mut hallway_points : Vec<Rc<Point>> = Vec::new();
        match self.dimension_options {
            Some(ref dimension_options) => {
                while self.chunks.len() > 0 {
                    let mut chunk = self.chunks.pop().expect("chunk not found in queue");
                    let new_chunk_option = chunk.split(&dimension_options, &mut self.rng);
                    match new_chunk_option {
                        Some(new_chunk) => {
                            match self.hallway_options {
                                Some(ref hallway_options) => {
                                    let can_strip_hallway = match new_chunk.chunk_split() {
                                        ChunkSplit::Vertical => {
                                            chunk.height() > hallway_options.min_hallway_length && chunk.width() > hallway_options.min_hallway_width
                                        },
                                        ChunkSplit::Horizontal => { 
                                            chunk.width() > hallway_options.min_hallway_length && chunk.height() > hallway_options.min_hallway_width
                                        }
                                    };
                                    if can_strip_hallway && total_hallway_percent < hallway_options.hallway_percent {
                                        let hallway_width = self.rng.gen_range(hallway_options.min_hallway_width, hallway_options.max_hallway_width);
                                        let hallway_chunk = chunk.strip_hallway(new_chunk.chunk_split(), hallway_width);
                                        let hallway_percent = (hallway_chunk.area() / self.total_area) * 100f32;
                                        total_hallway_percent = total_hallway_percent + hallway_percent;
                                        hallway_points.push(Rc::new(chunk.lower_left().clone()));
                                        hallway_points.push(Rc::new(Point::new(chunk.lower_left().x(), chunk.upper_right().y())));
                                        hallway_points.push(Rc::new(chunk.upper_right().clone()));
                                        hallway_points.push(Rc::new(Point::new(chunk.upper_right().x(), chunk.lower_left().y())));
                                    }
                                },
                                _ => {}
                            }

                            self.chunks.push(chunk);
                            self.chunks.push(new_chunk);
                        },
                        None => {
                            dungeon.add_room(Room::new(chunk));
                        }
                    }
                }
            },
            None => {
                panic!("dimension options must be set with 'with_dimension_options'")
            }
        }
        dungeon
    }

    fn merge_hallways(&self, hallway_points: &mut Vec<Rc<Point>>) -> Vec<Hallway> {
        hallway_points.sort_by(|a, b| a.compare_x_y(&b));
        let mut horizontal_edges : HashMap<u64, Rc<Point>> = HashMap::with_capacity(hallway_points.len());
        let mut vertical_edges : HashMap<u64, Rc<Point>> = HashMap::with_capacity(hallway_points.len());
        let mut idx = 0usize;
        let mut hallways : Vec<Hallway> = Vec::new();
        while idx < hallway_points.points.len() {
            vertical_edges.insert(hallway_points[idx].hash(), hallway_points[idx+1].clone());
            vertical_edges.insert(hallway_points[idx+1].hash(), hallway_points[idx].clone());
            idx = idx + 2;
        }
        hallway_points.sort_by(|a, b| a.compare_y_x(&b));
        idx = 0usize;
        while idx < hallway_points.len() {
            horizontal_edges.insert(hallway_points[idx].hash(), hallway_points[idx+1].clone());
            horizontal_edges.insert(hallway_points[idx+1].hash(), hallway_points[idx].clone());
            idx = idx + 2;
        }
        let first_point = hallway_points[0].clone();   
        let mut current_hash = first_point.hash();
        hallway_points.push(first_point);
        let mut next_hash = horizontal_edges.get(&current_hash).expect("Horizontal Point not found").hash();
        hallway_points.push(horizontal_edges.remove(&current_hash).unwrap());
        current_hash = next_hash;
        next_hash = vertical_edges.get(&current_hash).expect("Vertical Point not found").hash();
        while first_point.hash() != next_hash {
            hallway_points.push(vertical_edges.remove(&current_hash).unwrap());
            current_hash = next_hash;
            next_hash = horizontal_edges.get(&current_hash).expect("Horizontal Point not found").hash();
            hallway_points.push(horizontal_edges.remove(&current_hash).unwrap());
            current_hash = next_hash;
            if vertical_edges.get(&current_hash).is_none() {
                next_hash =first_point.hash();
            } else {
                next_hash = vertical_edges.get(&current_hash).expect("Vertical Point not found").hash();
            }
        }
    }

}

#[cfg(test)]
mod tests {
    use super::*;
    use point::Point;
    use dimensionoptions::DimensionOptions;

    #[test]
    fn test_build() {
        DungeonBuilder::new()
            .in_area(Point::new(0f32,0f32), Point::new(1000f32,1000f32))
            .with_dimension_options(DimensionOptions::new(5f32,5f32,5f32))
            .build();
    }
}
